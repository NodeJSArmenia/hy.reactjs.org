---
id: introducing-jsx
title: Ցանոթացում JSX-ի հետ
permalink: docs/introducing-jsx.html
prev: hello-world.html
next: rendering-elements.html
---

Դիտարկենք այս փոփոխականի հայտարարումը.

```js
const element = <h1>Ողջույն, աշխարհ</h1>;
```

Այս հետաքրքիր շարահյուսությունը ոչ տող է ոչ HTML։

Այն կոչվում է JSX և հանդիսանում է JavaScript-ի շարահյուսական ընդլայնում։ Մենք խորհուրդ ենք տալիս օգտագործել այն React-ի հետ\` սահմանելու համար թե ինչ տեսք պետք է ունենա UI-ը։ JSX-ը կարող է ձեզ հիշացնել ձևանմուշային լեզու, բայց այն ներառում է JavaScript-ի ամբողջ հզորությունը։

JSX-ը «արտադրում» է React էլեմենտներ։ Այն, թե ինչպես են նրանք արտապատկերվում DOM-ում, մենք կբացահայտենք [հաջորդ գլխում](/docs/rendering-elements.html)։ Վարը դուք կարող եք գտնել JSX-ի հետ աշխատել սկսելու համար անհրաժեշտ հիմքային գաղափարները։

### ինչու՞ JSX? {#why-jsx}

React-ը ընդունում է այն գաղափարը, որ արտապատկերման տրամաբանությունը ըստ էության կապված է UI տրամաբանության հետ. այն, թե ինչպես են իրադարձությունները մշակվում, թե ինչպես է state-ը փոփոխվում ժամանակի ընթացքում և, թե ինչպես են տվյալները պատրաստվում նկարվելու համար։

Ի տարբերություն *տեխնոլոգիաների*, որոնք արհեստականորեն բաժանում են նշարկումն(markup) ու տրամաբանությունը և օգտագործում նրանց առանձին ֆայլերում, React-ը կիրառում է [պատասխանատվության տարանջատում](https://en.wikipedia.org/wiki/Separation_of_concerns)<sub>`eng`</sub>\` «կեմպոնենտներ» կոչվող, միմյանց հետ թույլ կապված, բոլկերի հետ, որոնք երկուսն էլ պարունակում են։ Մենք դեռ կանդրադառնանք կոմպոնենտներին [հաջորդ գլխում](/docs/components-and-props.html)։ Բայց եթե դուք դեռ հարմարավետ չեք զգում նշարկումը JS-ի մեջ դնելու գաղափարի հետ, ապա [այս զեկույցը](https://www.youtube.com/watch?v=x7cQ3mrcKaY) միգուցե համոզի ձեզ հակառակում։

React-ը [չի պահանջում](/docs/react-without-jsx.html) JSX-ի օգտագործումը, բայց շատ մարդիկ համարում են դա հարմար, որպես վիզուալ օգնական, երբ JavaScript կոդի մեջ աշխատում եք UI-ի հետ։ Դա թույլ է տալիս React-ին ցույց տալ ավելի օգտակար ծանուցումներ սխալմների և զգուշացումների համար։

Սա հասկացանք, շարժվենք առաջ։

### Ներդրված արտահայտություններ JSX-ում {#embedding-expressions-in-jsx}

Վարը ներկայացվածը օրինակում, մենք հայտարարում ենք `name` անունով փոփոխական և օգտագործում այն JSX-ի ներսում\` փաթաթելով այն ձևավոր փակագծերով.

```js{1,2}
const name = 'Պողոս Պողոսյան';
const element = <h1>Ողջույն, {name}</h1>;

ReactDOM.render(
  element,
  document.getElementById('root')
);
```

JSX-ում\` ձևավոր փակագծերի ներսում, դուք կարող եք տեղադրել ցանկացած վավեր [JavaScript արտահայտություն](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions)<sub>`eng`</sub>։ Օրինակ. `2 + 2`, `user.firstName`, կամ `formatName(user)`. սրանք բոլորը վավել JavaScript արտահայտություններ են։

Իսկ այս մի օրինակում, մենք ներդնում ենք JavaScript ֆունկցիայի կանչի արդյունքը\` `formatName(user)`, `<h1>` էլեմենտի մեջ։

```js{12}
function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Պողոս',
  lastName: 'Պողոսյան'
};

const element = (
  <h1>
    Ողջույն, {formatName(user)}!
  </h1>
);

ReactDOM.render(
  element,
  document.getElementById('root')
);
```

[Փորձել CodePen-ում](codepen://introducing-jsx)

Մենք բաժանում ենք JSX-ը բազմակի տողերի ընթեռնելիության համար։ Այդպիսի դեպքերում, չնայած դա պարտադիր չէ, մենք նաև խորհուրդ ենք տալիս դնել դրանց փակագծերի մեջ\` [կետ-ստորակետների ավտոմատ տեղադրման](https://stackoverflow.com/q/2846283)<sub>`eng`</sub> ժամանակ անկանխատեսելի խնդիրներից խուսափելու համար։

### JSX-ը նույնպես արտահայտություն է {#jsx-is-an-expression-too}

Կոմպիլյացիայից հետո, JSX արտահայտությունները վերածվում են սովորական JavaScript ֆունկցիայի կանչի և հաշվարկվում որպես JavaScript օբյեկտ։

Սա նշանակում է, որ դուք կարող եք օգտագործել JSX-ը `if` պայմանի կամ `for` ցիկլի ներսում, վերագրել այն փոփոխականների, ընդունել այն որպես արգումենտ և վերադարձնել այն ֆունկցիաներից.

```js{3,5}
function getGreeting(user) {
  if (user) {
    return <h1>Ողջույն, {formatName(user)}!</h1>;
  }
  return <h1>Ողջույն անծանոթ։</h1>;
}
```

### Ատրիբուտների սահմանում JSX-ում {#specifying-attributes-with-jsx}

Դուք կարող եք օգտագործել ապաթարցեր հայտարարելու համար տողային լիտերալներ որպես ատրիբուտներ.

```js
const element = <div tabIndex="0"></div>;
```

Դուք նաև կարող եք օգտագործել ձևավոր փակագծեր ներդնելու համար JavaScropt արտահայտություններ ատրիբուտում.

```js
const element = <img src={user.avatarUrl}></img>;
```

Մի դրեք ապաթարցեր ձևավոր փակագծերի շուրջ երբ ներդրված է JavaScript արտահայտություն ատրիբուտում։ Դուք պետք է կամ օգտագործեք ապատարցեր (տողային արժեքների համար) կամ ձևավոր փակագծեր (արտահայտությունների համար), բայց ոչ երկուսը միասին նույն ատրիբուտում։

>**Զգուշացում:**
>
>Քանի որ JSX-ը ավելի մոտ է JavaScript-ին քան HTML-ին, ReactDOM-ը HTML ատրիբուտների անուների փոխարեն օգտագործում է `ուղտաԳիր` հատկությունների անունների պայմանավորվածություն։
>
>Օրինակ. `class`-ը JSX-ում դառնում է [`className`](https://developer.mozilla.org/en-US/docs/Web/API/Element/className)<sub>`eng`</sub>, `tabindex`-ը դառնում է [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex)<sub>`eng`</sub>։

### Զավակների հայտարարումը JSX-ում {#specifying-children-with-jsx}

Եթե թեգը դատարկ է, դուք կարող եք անմիջապես փակել այն սրանով `/>`, ինչպես XML-ում.

```js
const element = <img src={user.avatarUrl} />;
```

JSX թեգերը կարող են պարունակել զավակներ.

```js
const element = (
  <div>
    <h1>Ողջույն!</h1>
    <h2>Ուրախ ենք Ձեզ տեսնել այստեղ։</h2>
  </div>
);
```

### JSX-ը կանխում է ներարկման հարձակումները {#jsx-prevents-injection-attacks}

Ապահով է ներդնել օգտագործողի input-ը JSX-ում.

```js
const title = response.potentiallyMaliciousInput;
// This is safe:
const element = <h1>{title}</h1>;
```

Լռությամբ, ReactDOM-ը էկրանավորում է JSX-ում ներդրված ցանկացած արժեք մինչ նրանց արտապատկերումը։ Այդպիսով նա երաշխավորում է, որ դուք երբեք չեք կարող «ներարկել» այն ինչ ակնհայտորեն գրված չի ձեր հավելվածում։ Ամեն ինչ ձևափոխվում է տողի մինչ արտապատկերվելը։ Սա թույլ է տալիս կանխել [XSS (cross-site-scripting)](https://en.wikipedia.org/wiki/Cross-site_scripting)<sub>`eng`</sub> հարձակումները։

### JSX իրենից ներկայացնում է օբյեկտ {#jsx-represents-objects}

Babel-ը կոմպիլացնում է JSX-ը `React.createElement()` կանչերի։

Այս երկու օրինակները համարժեք են.

```js
const element = (
  <h1 className="greeting">
    Ողջույն, աշխարհ
  </h1>
);
```

```js
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Ողջույն, աշխարհ'
);
```

`React.createElement()`-ը կատարում է մի քանի ստուգում օգնելու համար ձեզ գրել սխալներից ազատ կոդ, բայց ըստ էության այն ստեղծում է այսպիսի օբյեկտ.

```js
// Նշում: այս կառուցվածքը պարզեցված ա
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Ողջույն, աշխարհ'
  }
};
```

Այս օբյեկտները կոչվում են «React էլեմենտներ»։ Դուք կարող եք դրանք համարել այն բաների նկարագրություն, որոնք ցանկանում եք տեսնել էկրանին։ React-ը կարդում է այդ օբյեկտները և օգտագերծում է նրանց DOM-ը կառուցելու և այն թարմ պահելու համար։

Մենք կուսումնասիրենք React էլեմենտների արտապատկերումը DOM-ում հաջորդ գլխում։

>**Խորհուրդ:**
>
>Մենք խորհուրդ ենք տալիս օգտագործել [«Babel լեզվի սահմանում»](https://babeljs.io/docs/editors) ձեր խմբագրիչի համար, որպեսզի ES6 և JSX կոդերը ճիշտ ընդգծվեն։ Այս վեբկայքը օգտագործում է [«Oceanic Next»](https://labs.voronianski.com/oceanic-next-color-scheme/) գունային սխեման, որը համատեղելի է դրա հետ։
